---
title: "파일럿 프로젝트, Jenkins 자동화 도구 적용기"
last_modified_at: 2023-04-28T07:20
categories:
- tech-seminar
tags:
  - 세미나
  - Jenkins
  - 파일럿프로젝트
  - CI/CD
  - 자동화
  - 이펙티브엔지니어
toc: true
toc_label: "목차"
toc_icon: "sort"
toc_sticky: true
---

``` 
해당 포스팅은 개발자 세미나 발표를 위해 작성되었습니다.
포스팅에서 사용하는 어휘나 문구가 부적절할 수 있습니다. 🙇‍♂️
```



---

# 로그포터와 개발자의 돌


![logpotter](https://user-images.githubusercontent.com/48559894/235003590-31295566-9679-4e7c-9fa2-5ba21afcf61b.png)



`login();`


안녕하세요. LogPotter 입니다. 

이번에 회사에서 **나만의 프로젝트로 자동화배포, Slack 알림봇 기능을 프로젝트에 적용**하였습니다.

예전부터 **불편하던 것들을 해소하고나니 참 편리하고 마법같은 기능들**이었습니다.


![](https://user-images.githubusercontent.com/48559894/235006636-ee8d0e00-9d22-48d1-b833-b715d58085ab.png)

> 와 자동화 배포! 지긋지긋한 수동 배포 이제 끝 ㅋㅋ <br>
> 와 에러 알림!
 

<br>


하지만 **의도한대로 적용되기까지 겪은 과정들에 난관**들도 참 많았습니다.

<br>

_나의 의도 : 모두를 편리하게! 익스펙토 펙트로늄!_

![](https://user-images.githubusercontent.com/48559894/235007439-d59f5f04-6353-4669-a6d6-551c647676ba.jpg)


<br>

_실제 동작 : 이잉! 아바다 케다브라!_

![](https://user-images.githubusercontent.com/48559894/235007999-8dd13279-08b8-4ab1-9f1b-cc8e8257a2b2.jpg)


![](https://user-images.githubusercontent.com/48559894/236065253-89e14f25-2435-47eb-bdc7-1d1b7a26b924.png)

_ㅋㅋ 서버 겁나 죽임_


---

## 뭐 했는데?

이번 나만의 프로젝트, 파일럿 프로젝트에서 저는 **아래와 같은 것들을 적용**해보았습니다.

- Jenkins 서버를 구축, 무중단 CI/CD 배포 구조를 적용
- CI/CD 진행상황, 결과 Slack Bot 메시지 전송
- 프로젝트 API 서버 Un Handling Exception 에러 메시지 Slack 발송
- 프로젝트 Batch 서버 Job 실행 실패 시 실패 내용 Slack 발송


### CI/CD Bot, Jengils

- 기능 
  - Github 특정 Repository의 특정 Branch에 Commit이 병합, 변경 시 <br> 자동으로 소스 통합, 배포 파일 생성 후 무중단 배포진행 및 진행 상황 알림


- 구조

![](https://user-images.githubusercontent.com/48559894/235543213-cc9121cb-53d4-4615-9c42-48efa9e08f2c.png)


- 구현물

![](https://user-images.githubusercontent.com/48559894/235546227-b98aa9dc-6f60-46c5-a61e-3162e5776165.png)

![](https://user-images.githubusercontent.com/48559894/236066171-65a5eea4-f2e0-414a-9916-0e35fbcbc68c.png)

_실패하면 실패 메시지랑, 실패 단계도 알랴줌, 이쁘죠_

<br>

_적용 과정 자체에 대한 내용은 다루지 않으므로 궁금하시면🧐 아래 링크로 고고_

_[Jenkins, Github WebHook을 활용한 CI/CD 적용 - Gillog](https://gil-log.github.io/ci-cd/Jenkins-Github-WebHook-CI-CD/)_

_[Nginx, Jenkins를 활용한 CI/CD 무중단 배포 - Gillog](https://gil-log.github.io/ci-cd/Nginx-Jenkins-%EB%AC%B4%EC%A4%91%EB%8B%A8-%EB%B0%B0%ED%8F%AC/)_

<br>

### 에러 알림 봇, Jenkills

- 기능 
  - API 서버 Handling 되지 않은 에러 알림
  - Batch Application Job 구동 실패 시 알림
  - 해당 쓰레드에 상세한 StackTrace 알림

- 구현물

![](https://user-images.githubusercontent.com/48559894/235801431-907b3381-fbee-45bb-830b-ed6fde8b6abe.png)

---

## 왜 저걸 했는데?


우선 이번 **파일럿 프로젝트에서 작업한 내용** 중,

**CI/CD 적용이 핵심 주제**라 **왜 CI/CD를 선정했는지** 부터 이야기 해보려 합니다.

_CI/CD가 뭔지?? [무중단배포, CI/CD란 - Gillog](https://gil-log.github.io/ci-cd/%EB%AC%B4%EC%A4%91%EB%8B%A8%EB%B0%B0%ED%8F%AC-CI-CD/)_

<br>


**개발자가 CI/CD, 자동화 배포를 적용하는 이유에는 아래와 같은 것들**이 있습니다.


- 자동화된 빌드로 빠른 릴리스 사이클, 높은 품질 코드
- 개발, 운영 서버 간의 경계 희석 피드백 주기 향상
- 빠른 배포 속도로 출시 주기 상승

뭐 이런 이유들이 있다고 하는데,

**제가 CI/CD 적용을 파일럿 프로젝트로 정한 시작점**은

**다 필요없고 지난 1년간 배포가 드럽게 귀찮아서** 였습니다.



![](https://user-images.githubusercontent.com/48559894/235543953-19c64840-fab1-4d87-952b-2b4c95f4e7a8.png)
_이전 1년 넘게 진행했던 프로젝트에서 배포 가이드_


<br>



또 배포 자체가 귀찮다보니, **한번 배포할 때 개발된 버전들을 한번에 모아서 배포하는 습관**이 들게되더라구요.

![](https://user-images.githubusercontent.com/48559894/235544582-1420cddc-e89b-4237-957a-c576466ac2b9.png)
_배포하기전 관련자들에게 노티를 매번..._

![](https://user-images.githubusercontent.com/48559894/235545417-6ac778ab-14f4-4880-8fff-5371ac7b4df9.png)

![](https://user-images.githubusercontent.com/48559894/235545502-962d3bb5-5ab0-4915-a2a1-a5bffa6a5104.png)

_API 개발되고 개발서버에 적용되면 매번 노티 + 한번에 쌓아두었다가 개발 서버 배포,,,(배포가 귀찮으니까,,)_

_개발되고 PR 머지도 되었지만, 개발 서버 배포까지, 모아두었다가 한번에 배포_

<br>

다 필요 없습니다.

**배포라는 작업이 엄청난 작업은 아닌데 엄청 귀찮은 작업**이어서,

**이걸 자동화 해야겠다라는 생각은 항상 마음**먹고 있었는데,

**바쁜 일정을 핑계**로, **다른 우선순위를 핑계**로 뒤로 미루고 있던걸,

이번 파일럿 프로젝트에서 적용하게 되었습니다.

![](https://user-images.githubusercontent.com/48559894/235545077-378ec5d5-25b1-43f4-a78a-89a60c1ecf27.png)
_마음은 2년전부터 가지고 있었다,, 미안 다른게 바빠서,,, 고생했다 2년간의 Gillog_


<br>


그 다음엔 이제 **에러 알림봇 `Jenkils`**인데,

해당 기능을 **파일럿 프로젝트에서 실현하려고 했던 배경은 단순**합니다.

**Spring Batch단 작업이 Local에서 구동시에는 크게 문제가 안되는 경우**가 많은데,

**매번 개발계에 올라가고 나면 여러가지 이유로 실패**하며,

**직접 Batch 실패 원인을 분석하는 일이 잦아서** 였습니다.

![](https://user-images.githubusercontent.com/48559894/235802672-f65010b9-b587-4b43-9f2c-d8b1c02cf248.png)

_무수히 많은 실패,, 아직도 다 못잡고 있는 중,,_

<br>

**Spring Batch에서는 Batch 결과에 대해 테이블에 저장되는 형태로 데이터가 저장**되는데, 


**현재는 잦은 주기로 Batch에서 Job들이 실패하는 경우**가 많아,

최종적으로는 결국 **매일 Batch 관련 테이블에 쿼리를 통해 실패한 Job들**이 있는지,

**실패 사유는 뭔지를 분석**하게 되지만,

<br>

**추후 대부분의 기능들이 안정화** 되고 나서는,

**매일 같이 쿼리를 날려 실패한 항목들이 있는지 검색하는 시간 자체**가,

**반복적으로 소요될 것을 생각**하였습니다.

_나중엔 몇개 실패 안할텐데 매일 쿼리날리면서 봐야되나??_

<br>

**API 서버에 대한 에러 알림은 이전에도 회사에서는 에러 알림 Slack 전송을 도입**하고 있었고,


![](https://user-images.githubusercontent.com/48559894/236063245-815c377e-c550-49ea-8035-232983e8b59e.png)

_밥먹다가도 뛰어나가서 에러 보고 그랬는데 ㅋㅋ_



**현재 작업중인 프로젝트에서는 아래와 같이 의도하는 API 실패 응답 반환 상황에 대한 것들을 정의** 하여,

**로직 중간에 예외를 터트리는 형태로 API 응답을 반환하도록 설계**되어 있는데,

![](https://user-images.githubusercontent.com/48559894/235803236-37d4faf8-d01c-4510-97a4-40379ac3195c.png)

![](https://user-images.githubusercontent.com/48559894/235803419-f5053b2c-22e1-4e37-aee5-29422cb3c11c.png)

**API 서버에서는 우리가 의도하지 않은 Exception들이 throw** 될 경우,

**인지하지 못하는 서버단 내부 에러나, 서버 문제가 발생하는 것을 감지**할 수 있게 되어,

API 서버에서는 **Handling 하고 있지 않은 Exception에 대해 신속한 인지와 대응을 위해 적용**하였습니다.


![](https://user-images.githubusercontent.com/48559894/235800520-889590a0-a20e-42c0-913e-8eb3aac5190c.png)

_터지자마자 호다닥 확인 가능_

<br>

---

## 뭘 말하려고?

진행한 파일럿 프로젝트의 핵심 문구는 `자동화` 였습니다. 

처음 시작점은 분명 `그냥 귀찮아서` 였고,

이번 파일럿 프로젝트를 통해 **얻고 싶었던 이점도 단순히 귀찮은걸 줄여서 편해지자 정도**였습니다.

그런데 프로젝트를 진행하며 읽은, 

**효율적인 개발자를 위한 서적, `이펙티브 엔지니어`에서 공감가던 내용들**과 **적용하고 나서 얻게 된 이점을 정리**해보니,

**단순히 귀찮음의 해소 보다 더 큰 가치들**이 있더라구요

<br>

이번 발표에서는 **파일럿 프로젝트를 진행하며 얻게되고, 알게된 가치들에 대해 이야기** 해보려 합니다.

---


## 시간 절약 도구에 투자하라


> 성공적인 사람들은 대부분 도구를 사용한다. <br>
> 문제를 발견했을 때 가장 먼저 도구부터 작성하는가는 <br>
> 그 사람의 성공 여부를 판가름하는 좋은 지표이다. <br>
> _by Boby Johnson of FaceBook Infra Engineer_


지난 최소 1년간 얼마나 많은 수동 배포를 진행했는지 모르겠습니다.

진행중인 이번 프로젝트에서 수동으로 배포하던 과정은 아래와 같았습니다.

- 배포 파일 준비
![](https://user-images.githubusercontent.com/48559894/235796065-edf37719-3223-4abc-8f0b-43519d15b2f9.png)

- 배포 서버로 파일 전송

![](https://user-images.githubusercontent.com/48559894/235796403-9b2f6ca2-36f1-4bff-a958-1aee597ec82d.png)

- 기존 프로세스 종료

![](https://user-images.githubusercontent.com/48559894/235796583-8d350706-5802-428b-9c92-3dbe38f96da0.png)

- 신규 배포 파일 구동

![](https://user-images.githubusercontent.com/48559894/235796827-86ce4c49-7ac7-46c8-bfd2-ef9602b6acd9.png)


이런 과정을 겪으며 배포를 진행하는 것에서 뼈저르게 느낀건

**반복적으로 동일한 작업을 수행한다** 였습니다.

<br>


현재의 배포 프로세스는 간단히 아래와 같이 변경되었습니다.

- Github 특정 branch에 PR Merge or Push

- Github Webhook 발송

![](https://user-images.githubusercontent.com/48559894/235797533-b8394c83-2f94-4718-af97-c82da80a0950.png)

- Jenkins CI/CD 진행

![](https://user-images.githubusercontent.com/48559894/235797943-c36b815f-7d33-4e17-aab0-3c27856b6b5c.png)

- 진행상황 Slack 발송

![](https://user-images.githubusercontent.com/48559894/235797738-8e57286d-25fd-4d0b-a2b2-4d9f76acce6c.png)


<br>

**지금까지 소모되었던, 앞으로 배포에 의해 소요될 시간을 고려**하면

**초기에 시간을 절약할 수 있는 자동화 도구에 대한 투자**는

**저희에게 시간 자체가 복리로** 돌아 오게 됩니다.

_귀찮음 해소, 편리함은 덤으로 ㅋㅋ_

<br>

관련되어 `이펙티브 엔지니어`에는 아래와 같은 구체적인 서술이 존재합니다.

_아래부터 In. 이펙티브 엔지니어_

> 속도가 빠르지만 개발 주기 반복의 병목 개선을 중요시 하지 않는 개발자와 <br>
> 속도가 느리지만 개발 주기 반복의 병목 개선을 중요시 하는 개발자가 있을 때, <br>
> 장기적 관점에서 후자의 개발자가, 더 빠르게 더 많은 결과를 생산하게 된다.


왜 **이런 결과가 발생하는지는 아래와 같은 이유가 존재**합니다.

<br>

### 더 빠른 도구가 더 많이 사용 된다

샌프란시스코에서 뉴욕으로 가는 유일한 교통편이 일주일 걸리는 기차뿐이었던, 1950년대 이전에는

사람들이 해당 경로를 자주 여행하지 않았지만,

여객 항공사의 등장으로 교통편의 종류가 늘어나고 소요 시간이 단축됨에 따라,

해당 경로를 더 자주 여행하게 되었다고 합니다.

<br>

만약 **어떤 도구가 반복적으로 수행하는 특정 작업의 시간을 줄여줄 수 있다면**,

**해당 도구를 더 자주 사용**하게 되면서, **해당 작업 수행 빈도도 높아 지게**되어  

최초 **예상한 도구가 절약해주는 시간 보다 더 많은 시간을 절약**할 수 있게 됩니다.

> 기존 : 매일 30분 A 작업 수행 <br>
> 도구 : A 작업을 20분 절약해줌 <br> <br>
> 기존 개발자 : 으~ A 작업 지겹다 최대한 적게 해야지 <br>
> 도구 도입 후 개발자 : ㅋㅋ 도구 쓰니까 겁나 단축되네 A 작업 더 자주 해야지 <br> <br>
> 예상이점 = 도구가 줄여주는 시간(20분) * 원래 작업 빈도(1/Day) <br>
> 실제이점 = 도구가 줄여주는 시간(20분) * 도구 도입 후 작업 빈도(2/Day) <br> <br>


### 확장된 도구는 팀 전체의 시간을 절약시킨다

구글, 페이스북, 드롭박스, 클라우데라 같은 **대규모 IT 회사들에는 사내에서 사용**하는,

**개발도구 만을 전담하여 개선, 개발 하는 전담팀이 존재**한다고 합니다.

<br>

**시간을 절약할 수 있는 도구가 개발되고 이 도구가 팀에 보급되어 확산**되게 될 경우,

**팀 전체적인 입장에서 얻는 이점은 N배**가 됩니다.


> 도구 사용 개발자 : 님들 A 작업 쉽게하는 도구 만들어 봤는데 함께 써보실래요? <br>
> 팀원들 : 헉, 넹 <br> <br>
> 도구 도입 후 이점 = 도구 사용으로 인한 이점 * 도구 사용 개발자 수


<br>

살펴본 예시와 같이 **시간 절약 도구에 대한 팀 전체적인 투자는 결국 복리로** 돌아오게 됩니다.


---

## Move Fast And Break Things



![](https://user-images.githubusercontent.com/48559894/235798387-f2fbcb8b-5694-4c1b-b16f-ad5764925e92.png)

> Move Fast And Break Things <br>
> _망가 뜨려도 좋으니 빠르게 실행하라_ <br>
> In. 페이스북 본사 복도

**망가지더라도 빠르게 움직여라 라는 문구**가

**8년만에 10억 명 이상 사용자를 확보한 페이스북의 핵심 기조 문구**라고 합니다.

<br>

**페이스북의 개발 문화는 보수적 태도 실수 최소화** 보다는,

**개발 주기를 빠르게 반복하며 효과를 내는데 집중**한다고 합니다.

<br>

자동화 배포 적용 전 앞서서 저는 앞서 말씀드렸듯이 **local에서 작업한 결과물들**을

**몇가지 쌓아두고 release를 생성하며 배포를 진행**했었습니다.


![](https://user-images.githubusercontent.com/48559894/235545502-962d3bb5-5ab0-4915-a2a1-a5bffa6a5104.png)

_API 개발되고 개발서버에 적용되면 매번 노티 + **한번에 쌓아두었다가 개발 서버 배포**,,,(배포가 귀찮으니까,,)_

<br>

개발된 여러 기능들이 한번에 서버에 적용되게 되면,

문제가 발생 했을때도 어떤 작업물에 의한 오류 사항인지 확인이 힘들어 집니다.

<br>

반면 **작업한 결과물들이 단위 단위로 매번 지속적으로 통합, 배포**되었을 때,


작업한 **한 단위의 개발 물이 실제 개발 환경에서 안정적으로 구동되는지**를,

**확인하는게 더 편리**했습니다.


<br>

![](https://user-images.githubusercontent.com/48559894/235800371-2d21f8a5-abbf-4185-95e2-0fbf63bf8325.png)

_잉? 갑자기 Handling 안되던 에러가?_


![](https://user-images.githubusercontent.com/48559894/235800337-9abb8cc1-6443-458c-9139-b11b84c078ca.png)

_마지막 배포된 작업이 이거? 너야?_

![](https://user-images.githubusercontent.com/48559894/235800520-889590a0-a20e-42c0-913e-8eb3aac5190c.png)

_바로 해당 소스본 작업자랑 대화_

<br>

하나 하나의 기능이 안정적으로 구동될 수 있도록,

신중을 기하는 것은 아주 중요하지만,

**지속적 배포를 통해 개발 버전 서버에 병합되는 개발주기를 빠르게** 가져가고, 

**빠르게 원인을 파악할 수 있도록 환경을 조성하는 것**이,

**더 안정적인 기능 구현, 서비스 제공에 필요하다는 걸 경험**하게되었습니다.

<br>



---

## 레버리지

해보려던 리서치한 툴들, Grafna나 생각했던 구조

아래는 도입하지 않은 이유

### 메모리 모니터링

막상 해놔봤자 쓸줄도 모르고 이걸 활용하지 않게 될 것이 분명



```
레버리지 = 생산한 효과 / 투자한 시간
```


.log랑 dump 생성 옵션 추  한 부분

---



---

## 적용 과정 이슈

이슈들 아래

### 1024 미만 포트 Root 구동

구동 포트1024로 구동하려니까 jenkins 사용자에서 안되던거

### Java Application이 무겁다

gradle 실행 이게 기본 메모리가 이렇게 빌드 따는거만 해도 죽었었던것

### 인스턴스 교체 될 때 jar파일 명 중복 관련

파일명 jar 똑같으니까 기존 인스턴스에 영향 가던 것


---

`logout();`
